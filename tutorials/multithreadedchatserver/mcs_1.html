<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.26" />
  <meta name="author" content="Joshua Crotts">
  <meta name="description" content="Computer Science Student">
  <link rel='shortcut icon' type='image/x-icon' href='img/favicon.ico' />
  <link rel="stylesheet" href="./css/highlight.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.0/css/academicons.min.css"
    integrity="sha512-GGGNUPDhnG8LEAEDsjqYIQns+Gu8RBs4j5XGlxl7UfRaZBhCCm5jenJkeJL8uPuOXGqgl8/H1gjlWQDRjd3cUQ=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"
    integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="../../css/hugo-academic.css">
  <link rel="stylesheet" href="../../css/styles.css">
  <link href="../../css/prism.css" rel="stylesheet" />
  <script>
    window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) }; ga.l = +new Date;
    ga('create', 'UA-104968519-1', 'auto');
    ga('require', 'eventTracker');
    ga('require', 'outboundLinkTracker');
    ga('require', 'urlChangeTracker');
    ga('send', 'pageview');
  </script>
  <script async src="https://www.google-analytics.com/analytics.js"></script>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js"
    integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g=="
    crossorigin="anonymous"></script>
  <script src="../../js/prism.js"></script>
  <link rel="alternate" href="./index.xml" type="application/rss+xml" title="Joshua Crotts">
  <link rel="feed" href="./index.xml" type="application/rss+xml" title="Joshua Crotts">
  <link rel="icon" type="image/png" href="../../img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="../../img/apple-touch-icon.png">
  <link rel="canonical" href="./">
  <title>Joshua Crotts</title>
</head>

<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">
  <nav class="navbar navbar-default navbar-fixed-top" style="background-color: #0f2044;" id="navbar-main">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse"
          aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./">Joshua Crotts</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-item">
            <a href="../../index.html" data-target="#about">
              <span>Home</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../courses.html" alt="Courses">
              <span>Courses</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../research.html" alt="Research">
              <span>Research</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../projects.html" alt="Projects">
              <span>Projects</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../tutorials.html" alt="Tutorials">
              <span>Tutorials</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../contact.html" , alt="Contact">
              <span>Contact</span>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <section id="courses" class="home-section">
    <div class="container">
      <div class="row" style="text-align: justify;">
        <h1>Multithreaded Chat Server in C and Java!</h1>
        <p>Building the server - Part 1 IN PROGRESS</p>
        <p class="author">Author: Joshua Crotts</p>
        <p class="author">Date: 2021/05/17</p>
        <p>To begin, we are going to create a GitHub repository for our project. You can do this on your own, but I
          called mine <code>Multithreaded-Chat-Server-Tutorial</code>. Once you do this, clone it to your computer
          wherever you would like, but preferably a location that you can access through the terminal easily (since
          we’ll be running a lot of commands like <code>make</code> and whatnot). </p>
        <p>Now, inside this repository folder, it will either be blank, or contain a file or two, depending on how you
          set it up. We need to create a few things:</p>
        <ol>
          <li>First, create a directory called <code>src</code>. This is where all of the C source <code>.c</code> files
            will be stored.</li>
          <li>Then, create a directory called <code>include</code>. This will be where we store all header files
            <code>.h</code>.
          </li>
          <li>Create a file called <code>.gitignore</code> (with no extension!). Because we are using GitHub, there are
            some files that we don’t want to upload to the remote repository like the executables and object files that
            are generated from compiling the program. We’ll come back to this file a bit later. </li>
          <li>Lastly, create a file called Makefile (no extension!). A makefile is essential to any large C project – it
            makes compilation and linking a breeze!</li>
        </ol>
        <p><i>Note: Some people may disagree with this file structure – keeping the source and include files separate.
            You can structure the project however you want, but this is how I like to do it.</i></p>
        <p>So, your directory should look like this:</p>
        <center><img src="mcsimages/dir1.png" /></center>
        <br />
        <p><i>Note that the gitignore file is hidden by default (that's what the period in front of the name does!).</i></p>
        <p>Open this root folder in a developer environment (that can be Vim, Visual Studio Code (VSCode), or whatever
          else – I’ll be using VSCode). Now it’s time to start coding!</p>

        <p>The first thing we’re going to actually write is the server itself. A server receives connections from
          clients and dispatches messages across them. For our purposes, the server is going to receive commands and
          messages from the client (user), and it will handle them accordingly. There’s a lot that goes into this, so
          we’ll break it down one step at a time. For now, let’s just handle getting <i>a</i> connection established.
        </p>

        Create a file called <code>server.c</code> in the <code>src</code> directory and <code>server.h</code> in the
        include directory. We’ll start off with the header file. We need a few definitions to get started: namely the
        connection IP to use, some function prototypes, and constants. Let’s just jump right into it:
        <pre class="line-numbers">
          <code class="language-clike">
        #ifndef SERVER_H
        #define SERVER_H
       
        typedef struct server_s {
          int socket_fd;   /* Socket file descriptor. */
          int flags;       /* Flags for the server.   */
        } server_t;
       
        enum SERVER_FLAGS {
            SERVER_ACTIVE = 1
        };
       
        extern server_t server;
       
        extern void server_init( void );
       
        #endif // SERVER_H
            </code>
            </pre>
        <p>The first thing we do is create a <code>typedef</code> for a server structure. This structure will hold a few
          things, such as the clients that connect, the threads that handle jobs, etc. These definitions will be made
          later, once we get there. We also include a flag variable to keep track of the status of the server. The enum
          we define is simply for bookkeeping - we can store all flags that we want to use for the server here instead
          of doing a bunch of <code>const int</code>'s or preprocessor <code>#define</code>'s. Also note that we have a
          socket "fd". fd stands for <i>file descriptor</i>. A file descriptor is a handle, so to speak, meaning that
          this integer keeps track of the socket (connection) identifier once it is established. We need this to listen
          for clients later on.</p>
        <p>We also create a variable of type <code>server_t</code> to reference in the <code>server.c</code> file.
          Global references/variables are generally frowned upon, but this is, effectively, the only way to do this in
          C. Plus, it'll be the only global we use, so it's a good compromise.</p>
        <p><code>server_init</code> will initialize the socket listener and other miscellaneous things. Let's go define
          that!</p>
          <pre class="line-numbers">
            <code class="language-clike">
          #include &lt;arpa/inet.h&gt;
          #include &lt;errno.h&gt;
          #include &lt;netdb.h&gt;
          #include &lt;netinet/in.h&gt;
          #include &lt;signal.h&gt;
          #include &lt;stdio.h&gt;
          #include &lt;stdlib.h&gt;
          #include &lt;string.h&gt;
          #include &lt;sys/socket.h&gt;
          #include &lt;sys/types.h&gt;
          #include &lt;unistd.h&gt;
          
          #include "tcpdefs.h"
          #include "server.h"
          
          static int server_create_listener( const char *server );
          
          void
          server_init( void ) {
            int socket_fd;
            socket_fd = server_create_listener( PORT );
            printf( "Socket fd: %d\n", socket_fd );
          }
          
          static int
          server_create_listener( const char *server ) {
              int socket_fd;
              if ( ( socket_fd = socket( AF_INET, SOCK_STREAM, 0 ) ) &lt; 0 ) {
                perror( "Could not initialize socket.\n" );
                return -1;
              }
              return socket_fd;
          }
  </code></pre>
      <p>Now, I'm sure you're thinking: "Wow, that's a <i>lot</i> of additions!" Well, we're not even half of the way there, so don't get too excited just yet! The first thing we've done is included a bunch of C headers. Don't worry if you don't know where a lot of this stuff comes from - just include them for now.</p>
      <p>Next, we include our <code>server.h</code> header which is nice, but what about <code>tcpdefs.h</code>? What's that, you ask? Well, we need a way of explicitly telling our server what port to start the server on. We're going to use port 8080, which is an alternate port for HTTP. The function that we need to pass this to, strangely enough, takes in the value as a string. So, since we may need to define more things for this connection (which, by the way, is TCP-based!), we're going to store these constants and other data in a header.</p>
      <pre class="line-numbers">
        <code class="language-clike">
          #ifndef TCP_DEFS_H
          #define TCP_DEFS_H

          const char *PORT = "8080";

          #endif // TCP_DEFS_H
          </code>
          </pre>
          <p>Yep, that's all there is to that! So, just make sure to include it in your <code>server.c</code> file, and we'll get back to that.</p>
          <br />
          <p>Let's talk about that <code>server_create_listener</code> function for a moment. Recall that a server listens for connections, right? Well, we have to initialize how the server actually listens before we start the listening itself. We need to initialize what's called a socket, which is just a connection between two endpoints. This socket will use TCP - a connection-based protocol, meaning that each message to and from the server has guaranteed delivery, compared to UDP which fires packets and ignores dropped ones. Since this is a chat server, we don't want packets of data to be randomly lost! We also want to set this server up to use IPv4 addressing.</p>
          <p>To do both of these, we use the <code>socket</code> function which takes three parameters: a domain, a type, and a protocol. We want the domain to be <code>AF_INET</code>, representing IPv4 addressing. The type is <code>SOCK_STREAM</code> for TCP connectivity (or connection-oriented). The last parameter is a protocol, and you may be asking: didn't we just set a protocol for the first parameter? Yes, we did. Because that's the case, this can be set to 0. For more information, check out <code>man socket(2)</code>.</p>
          <p><i>Note: the man pages are extremely helpful for learning about Linux commands and C functions. To investigate, just type in the terminal (or google) <code>man</code> then the accompanying function.</i></p>
          <p>The <code>socket</code> function is from the <code>&lt;sys/socket.h&gt;</code> header, so at least it's easy to remember! But, notice that we check its return value <i>inside</i> the <code>if</code> statement - this is a common and idiomatic way of checking C return values that need to be assigned. <code>socket()</code> returns an integer - that integer is the endpoint for the connection that we want to establish. However, if an error occurs, <code>-1</code> is returned. Thus, checking to see if the value is less than 0 is a good way to error check. This will be a common practice throughout development (especially when allocating dynamic memory!).</p>
          <p>Let's keep going (note that I only returned/printed values in these two starter functions for demonstrative purposes).</p>
          <br />
          <p>One issue that may (and will!) arise during debugging is the need to quickly retest the server. If the server is shutdown, there may still be sockets connected to its port upon restarting and listening. To prevent this, we utilize the <code>setsockopt</code>function with its <code>SO_REUSEPORT</code> flag.</code></p>
          <pre class="line-numbers">
            <code class="language-clike">
              int optval = 1;
              setsockopt( socket_fd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof( optval ) );
              </code>
            </pre>
            <br />
              <p>Now, we need to initialize a connection. However, we can't just accept a connection to any available IP. That's why we use what are called "hints". These hints will allow the program to find a list of possible connections, and we can choose the one we need off said list.</p>
            <pre class="line-numbers">
              <code class="language-clike">
                struct addrinfo hints;
                memset( &hints, 0, sizeof( hints ) );
              hints.ai_flags = AI_PASSIVE;
              hints.ai_family = AF_INET;
                hints.ai_socktype = SOCK_STREAM;
                hints.ai_protocol = 0;
                    
                struct addrinfo *result;
                int              return_val;
              if ( ( return_val = getaddrinfo( NULL, server, &hints, &result ) ) != 0 ) { 
               fprintf( stderr, "Error in getaddrinfo: %s\n", gai_strerror( return_val ) );
                  close( socket_fd );
                  return -1; 
              </code>
            </pre>
            <p>The first thing is to create an <code>addrinfo</code> struct and set its necessary fields to send off to the <code>getaddrinfo</code> function. <code>getaddrinfo</code> takes in a few parameters, but the important one is the pointer to the <code>struct addrinfo *result</code>. To some, this may seem a little weird, but all this is doing is declaring a linked list. Since we're passing in a double pointer, the <code>getaddrinfo</code> function will populate (and dynamically allocate, so remember to free it later with <code>freeaddrinfo</code>!) this list. From there, we can poll the list to get our connection. Note that we should iterate down this list to find the connection, but for now, we can just remove the first one off the list (note that we haven't actually done this yet).</code></p>
            <br />
            <p>Next, we will bind the resulting connection returned from the result linked list (the head of it, rather) to our socket.</p>
            <pre class="line-numbers">
              <code class="language-clike">
                int bind_return_val = bind( socket_fd, result->ai_addr, result->ai_addrlen );
                if ( bind_return_val < 0 ) {
                  perror( "DEBUG: Could not bind name and address to socket.\n" );
                  close( socket_fd );
                  return -1;
                }
              </code>
            </pre>
            <p>We pass in the socket file descriptor, address, and address length from the result linked list head element. Note that in this code and the previous block, we do error checking. This, again, is extremely important to do! Note that if the bind fails, we close the socket file descriptor. This is, while not <i>imperative</i> since the program is closing anyways (and hence all memory and file descriptors are freed), it is still good practice.</p>
            <p>We're almost done with this function! The last thing to do is set up the listener with the, you guessed it, <code>listen</code> function.
              <pre class="line-numbers">
                <code class="language-clike">
                  int listen_return_val = listen( socket_fd, 256 );
                  if ( listen_return_val &lt; 0 ) {
                    perror( "DEBUG: Could not initialize socket listener.\n" );
                    close( socket_fd );
                    return -1;
                  }
                </code>
              </pre>
              <p><code>listen</code> takes two parameters: the socket file descriptor that we have been using repeatedly, and the number of concurrent connections. We'll use 256, but you could set this higher in theory.</p>
              <p>Great! The final thing to do is free the memory from the linked list that <code>getaddrinfo</code> created, and to return the socket, since we'll have to repeatedly check for connections in a different function.</p>
              <pre class="line-numbers">
                <code class="language-clike">
                  freeaddrinfo( result );
                  return socket_fd;
                </code>
              </pre>
        </div>
    </div>
  </section>
</body>

</html>