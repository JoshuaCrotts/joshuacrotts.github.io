<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.26" />
  <meta name="author" content="Joshua Crotts">
  <meta name="description" content="Computer Science Student">
  <link rel='shortcut icon' type='image/x-icon' href='img/favicon.ico' />
  <link rel="stylesheet" href="./css/highlight.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.0/css/academicons.min.css"
    integrity="sha512-GGGNUPDhnG8LEAEDsjqYIQns+Gu8RBs4j5XGlxl7UfRaZBhCCm5jenJkeJL8uPuOXGqgl8/H1gjlWQDRjd3cUQ=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"
    integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="../../css/hugo-academic.css">
  <link rel="stylesheet" href="../../css/styles.css">
  <link href="../../css/prism.css" rel="stylesheet" />
  <script>
    window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) }; ga.l = +new Date;
    ga('create', 'UA-104968519-1', 'auto');
    ga('require', 'eventTracker');
    ga('require', 'outboundLinkTracker');
    ga('require', 'urlChangeTracker');
    ga('send', 'pageview');
  </script>
  <script async src="https://www.google-analytics.com/analytics.js"></script>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js"
    integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g=="
    crossorigin="anonymous"></script>
  <script src="../../js/prism.js"></script>
  <link rel="alternate" href="./index.xml" type="application/rss+xml" title="Joshua Crotts">
  <link rel="feed" href="./index.xml" type="application/rss+xml" title="Joshua Crotts">
  <link rel="icon" type="image/png" href="../../img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="../../img/apple-touch-icon.png">
  <link rel="canonical" href="./">
  <title>Joshua Crotts</title>
</head>

<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">
  <nav class="navbar navbar-default navbar-fixed-top" style="background-color: #0f2044;" id="navbar-main">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse"
          aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./">Joshua Crotts</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-item">
            <a href="../../index.html" data-target="#about">
              <span>Home</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../courses.html" alt="Courses">
              <span>Courses</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../research.html" alt="Research">
              <span>Research</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../projects.html" alt="Projects">
              <span>Projects</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../tutorials.html" alt="Tutorials">
              <span>Tutorials</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../contact.html" , alt="Contact">
              <span>Contact</span>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <section id="courses" class="home-section">
    <div class="container">
      <div class="row" style="text-align: justify;">
        <h1>Multithreaded Chat Server in C and Java!</h1>
        <p>Creating clients - Part 2 </p>
        <p class="author">Author: Joshua Crotts</p>
        <p class="author">Date: 2021/05/21</p>
        <p>Welcome back! In this tutorial, we'll make the structs and data associated with a client. However, I want to
          introduce a topic first. See, when we create the server, we need a way of keeping track of clients. We ought
          to store them in some type of data structure so we can traverse it and find clients for later lookup. How can
          we do that, you ask?
        </p>
        <p>Normally, if you were efficient, you may want to do some sort of <code>TreeSet</code> or something like that
          to ensure that clients are ordered for quick searches down the road, but for this project where there won't be
          more than 5 clients connected, it's perfectly reasonable to go with a standard linked list.</p>
        <p>A linked list, for those unfamiliar, is a data structure similar to an array, but different in that there is
          no such thing as contiguous memory - everything is linked together by pointers. So, instead of having an
          "index", each element is called a "node". All nodes will point to another node, namely, their successor. So,
          the head, or the front of the list points to the next element in line. That element points to the next "next"
          element, and so on and so forth.</p>
        <p>This specific kind of linked list is called a singly-linked list - you can kind more about the details
          online. We are going to create what's called a <i>doubly</i> linked list. The difference is that instead of
          only having one pointer (namely, to the next node in succession), each node will have <i>two</i>: one for the
          next node, and one for the <i>previous</i>. This will make removing and inserting clients much easier down the
          road.</p>
        <p>I won't go too into details about the implementation of the data structure <i>itself</i>, since that's
          effectively a prerequisite. However, I will provide details on the code related to the networking and whatnot.
          Let's get started!</p>
        <br />
        <p>Firstly, let's create a header file called <code>client.h</code> and a source called <code>client.c</code>.
        </p>
        <pre class="line-numbers">
          <code class="language-clike">
            #ifndef CLIENT_H
            #define CLIENT_H
            
            #include &lt;stdio.h&gt;

            // TODO client.h

            #endif // CLIENT_H
          </code>
        </pre>
        <pre class="line-numbers">
          <code class="language-clike">
            #include "client.h"

            // TODO client.c
          </code>
        </pre>
        <p>Neat. Now, let's talk about what the header file needs. We need three things: a linked list, a type for the
          linked list nodes, and a type for the client itself.</p>
        <p>The linked list structure will have:
        <ul>
          <li>A pointer to the head node of the list, NULL if list is empty</li>
          <li>A pointer to the tail node of the list, NULL if list is empty</li>
          <li>A size variable denoting how many clients are in the list</li>
        </ul>
        </p>
        <p>The linked list <i>node</i> structure will have:
        <ul>
          <li>A pointer to the node immediately after this node, NULL if none.</li>
          <li>A pointer to the tail immediately before this node, NULL if none.</li>
          <li>A pointer to the client struct that this node represents (the data itself!)</li>
        </ul>
        </p>
        <p>And finally, the client itself will have multiple things, and we may need to extend this definition later.
          For now, though:
        <ul>
          <li>A communication file descriptor</li>
          <li>A name</li>
          <li>A pointer to the write FILE.</li>
          <li>A pointer to the read FILE.</li>
        </ul>
        </p>
        <p>We'll expand on those last two in the client struct in a bit, but the first two should be trivial if you
          understand linked lists (if not, please read about them before proceeding - they are super important!). So,
          let's code them up!</p>
        <pre class="line-numbers">
          <code class="language-clike">
            /**
             * Typedef for the list itself. Keeps track of two pointers:
             * the head and the rear of the list. 
             */
            typedef struct client_list_s {
              struct client_node_s *head;   /* Head (first element) of the list. */
              struct client_node_s *tail;   /* Tail (last element) of the list. */
              size_t size;                  /* Number of currently-connected clients. */
            } client_list_t;

            /**
             * Node in the linked list. Abstracts the client_s struct and keeps 
             * two pointers: the previous node and the next node.
             */
            struct client_node_s {
              struct client_s *client;
              struct client_node_s *next;
              struct client_node_s *prev;
            };
          </code>
        </pre>
        <p>Let's discuss the client type for a minute (haven't coded it yet). Recall that when a client connects to the
          server in the connection while loop, we get two things: the name, and the communication file descriptor. These
          are the two (obvious) fields that we named earlier, but we also named two others: the read and write
          <code>FILE</code> pointers. If you've ever messed with file IO in C, <code>FILE *</code> should make sense to
          you. If not, however, it's still relatively simple.</p>
        <p>There are three "primary" types of file streams: standard input, standard output, and standard error. These,
          in C, are listed as <code>stdin, stdout, stderr</code> respectively. We can mimic the behavior of these file
          streams using <code>FILE</code> pointers with that communication file descriptor. We need to be able to read
          and write to the socket, right? So, how can we do that? It's simple, really (I know I keep saying that, but
          the concept itself is - the underlying code may be a bit more confusing to some)! We can use that unique
          communication file descriptor that we get from accept, and create <code>FILE</code> pointer objects from them,
          and dedicate one to reading, and one to writing!</p>
        <p>I hear some of you asking: "Why not just create <i>one</i> <code>FILE</code> pointer and use that instead?"
          Great question! The issue with this is that, when attempting to read from the client using only one file
          descriptor (or <code>FILE *</code> in this context), for instance, there can be no other activity on that file
          descriptor, meaning we can't write to the client at all until the read is complete. That's why we dedicate two
          <i>duplicate</i> file descriptors for this. Effectively, we create two pipes: one solely for reading, and one
          solely for writing for <i>that specific client and only that specific client.</i> Sounds confusing at first, I
          know! Let's start off by writing the client struct.</p>
        <pre class="line-numbers">
            <code class="language-clike">
              struct client_s {
                char *username;
                int comm_fd;
                
                FILE *read_fp;
                FILE *write_fp;
            };
            </code>
          </pre>
        <p>So far so good, eh? Again, the first two fields should be clear - they're retrieved from the
          <code>accept</code> call. The two bottom ones may be a bit fuzzy, but you can think of them as "links". You
          can use <code> FILE *</code> for reading any type of connection (for the most part - this may need
          fact-checking...)! You can read not only from sockets like we're doing, but also from files directly (which is
          generally what it's used for). Of course, we <i>could</i> just use the <code>read</code> and
          <code>write</code> or <code>send</code> and <code>recv</code> functions, but those are lower level, and using
          <code>FILE *</code> allows us to use high-level and string-friendly functions such as <code>fgets</code> and
          <code>getline</code>.</p>
        <p>Alright, let's get started with <code>client.c</code>:</p>
        <pre class="line-numbers">
            <code class="language-clike">
                #include &lt;string.h&gt;
                #include &lt;stdio.h&gt;
                #include &lt;stdlib.h&gt;

                #include "client.h"
                
                void
                client_create( int comm_fd ) {
                  // Dynamically allocate struct.
                  struct client_s *client = malloc( sizeof( struct client_s ) );
                  if ( client == NULL ) {
                    perror( "Could not allocate memory for client struct.\n" );
                    exit( EXIT_FAILURE );
                  }
                  memset( client, 0, sizeof( struct client_s ) );
                  // TODO...
                }
            </code>
          </pre>
        <p>When we <code>accept</code> the client request, we're going to create and dynamically allocate a client
          struct. From here, we'll need to make a couple of modifications to the header file so <code>server.c</code>
          can call this function.</p>
        <p>Add the <code>extern void client_create( int comm_fd );</code> prototype to <code>client.h</code>, and
          include <code>client.h</code> in <code>server.c</code>. Those are all the modifications for now.</p>
        <p>Next, let's create the pipes for reading and writing to the client. Recall that the file descriptor <i>is</i>
          a pipe for this, but because we want to read and write at the same time to and from the client, we need to
          make use of the <code>dup()</code> function. This function returns a duplicated copy of the file descriptor.
          Since we need two new links, we can call <code>dup</code> twice and dedicate one file descriptor for reading,
          and one for writing. Note that, to do this, you need to include two new headers: <code>unistd.h</code>, and
          <code>fcntl.h</code>. So, here's what I mean:</p>
        <pre class="line-numbers">
            <code class="language-clike">
              // Create the read and write file descriptors.
              client->comm_fd = comm_fd;
              int read_fd = dup( client->comm_fd );
              int write_fd = dup( client->comm_fd );
            
              // Now attach them to FILE *s.
              client->read_fp = fdopen( read_fd, "r" );
              client->write_fp = fdopen( write_fd, "w" );
            </code>
          </pre>
        <p>Notice what we're doing here: after we create the two unique file descriptors, we attach them to
          <code>FILE *</code> with the <code>fdopen</code> function (conveniently named "file-descriptor open"!). You
          may have seen a variant of this called <code>fopen</code>. The difference here is that we're operating with a
          file descriptor integer rather than a path location or filename. Again, we do this so we have access to
          high-level functions for string processing/parsing later on - it makes our lives much easier!</p>
        <p>For now, that's all we'll do. Let's write the client cleanup function, of course!</p>
        <pre class="line-numbers">
            <code class="language-clike">
              void 
              client_destroy( struct client_s *client ) {
                // Free the name if it exists.
                if ( client->username != NULL ) {
                  free( client->username );
                }

                if ( fclose( client->read_fp ) < 0 ) {
                  perror( "Could not close client's read file ptr.\n" );
                  exit ( EXIT_FAILURE );
                }

                if ( fclose( client->write_fp ) < 0 ) {
                  perror( "Could not close client's write file ptr.\n" );
                  exit( EXIT_FAILURE );
                }

                free( client );
              }
            </code>
            </pre>
        <p>You may be wondering: what is <code>username</code>? Remember it's that <code>char *</code> in the struct! We
          haven't done anything with it yet because 1. we're not passing the IP address from the server to the
          <code>client_create</code> function as there's no real need to, and 2. because it's not a static char array,
          we have to check to see if it has been <code>malloc</code>'d, and if so, free it. We'll come back to this
          later.</p>
        <p>The rest of the code should make sense. We're closing the file pointers and if an error occurs, we just bail
          out. Finally, we free the memory associated with the client. Make sure to add this function to the header.</p>
        <p>Awesome. Since I want to make these parts a bit shorter, we'll stop here for now, and next time we'll
          actually build the doubly linked list to store clients once they connect. Check the latest part 2 release tag
          for the latest changes, including the oh-so-slightly updated Makefile.</p>
        <p><a href="https://github.com/JoshuaCrotts/Multithreaded-Chat-Server-Tutorial/releases/tag/part2">GitHub Code
            for Part 2.</a></p>
      </div>
    </div>
  </section>
</body>

</html>