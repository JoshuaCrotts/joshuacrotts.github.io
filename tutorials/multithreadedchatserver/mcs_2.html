<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.26" />
  <meta name="author" content="Joshua Crotts">
  <meta name="description" content="Computer Science Student">
  <link rel='shortcut icon' type='image/x-icon' href='img/favicon.ico' />
  <link rel="stylesheet" href="./css/highlight.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css"
    integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.0/css/academicons.min.css"
    integrity="sha512-GGGNUPDhnG8LEAEDsjqYIQns+Gu8RBs4j5XGlxl7UfRaZBhCCm5jenJkeJL8uPuOXGqgl8/H1gjlWQDRjd3cUQ=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"
    integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw=="
    crossorigin="anonymous">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="../../css/hugo-academic.css">
  <link rel="stylesheet" href="../../css/styles.css">
  <link href="../../css/prism.css" rel="stylesheet" />
  <script>
    window.ga = window.ga || function () { (ga.q = ga.q || []).push(arguments) }; ga.l = +new Date;
    ga('create', 'UA-104968519-1', 'auto');
    ga('require', 'eventTracker');
    ga('require', 'outboundLinkTracker');
    ga('require', 'urlChangeTracker');
    ga('send', 'pageview');
  </script>
  <script async src="https://www.google-analytics.com/analytics.js"></script>
  <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js"
    integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g=="
    crossorigin="anonymous"></script>
  <script src="../../js/prism.js"></script>
  <link rel="alternate" href="./index.xml" type="application/rss+xml" title="Joshua Crotts">
  <link rel="feed" href="./index.xml" type="application/rss+xml" title="Joshua Crotts">
  <link rel="icon" type="image/png" href="../../img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="../../img/apple-touch-icon.png">
  <link rel="canonical" href="./">
  <title>Joshua Crotts</title>
</head>

<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">
  <nav class="navbar navbar-default navbar-fixed-top" style="background-color: #0f2044;" id="navbar-main">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse"
          aria-expanded="false">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="./">Joshua Crotts</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li class="nav-item">
            <a href="../../index.html" data-target="#about">
              <span>Home</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../courses.html" alt="Courses">
              <span>Courses</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../research.html" alt="Research">
              <span>Research</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../projects.html" alt="Projects">
              <span>Projects</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../tutorials.html" alt="Tutorials">
              <span>Tutorials</span>
            </a>
          </li>
          <li class="nav-item">
            <a href="../../contact.html" , alt="Contact">
              <span>Contact</span>
            </a>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <section id="courses" class="home-section">
    <div class="container">
      <div class="row" style="text-align: justify;">
        <h1>Multithreaded Chat Server in C and Java!</h1>
        <p>Storing clients - Part 2 IN PROGRESS</p>
        <p class="author">Author: Joshua Crotts</p>
        <p class="author">Date: 2021/05/20</p>
        <p>Welcome back! In this tutorial, we'll be making the data structure that stores each client for later lookup.
        </p>
        <br />
        <p>Normally, if you were efficient, you may want to do some sort of <code>TreeSet</code> or something like that
          to ensure that clients are ordered for quick searches down the road, but for this project where there won't be
          more than 5 clients connected, it's perfectly reasonable to go with a standard linked list.</p>
        <p>A linked list, for those unfamiliar, is a data structure similar to an array, but different in that there is
          no such thing as contiguous memory - everything is linked together by pointers. So, instead of having an
          "index", each element is called a "node". All nodes will point to another node, namely, their successor. So,
          the head, or the front of the list points to the next element in line. That element points to the next "next"
          element, and so on and so forth.</p>
        <p>This specific kind of linked list is called a singly-linked list - you can kind more about the details
          online. We are going to create what's called a <i>doubly</i> linked list. The difference is that instead of
          only having one pointer (namely, to the next node in succession), each node will have <i>two</i>: one for the
          next node, and one for the <i>previous</i>. This will make removing and inserting clients much easier down the
          road.</p>
        <p>I won't go too into details about the implementation of the data structure <i>itself</i>, since that's
          effectively a prerequisite. However, I will provide details on the code related to the networking and whatnot.
          Let's get started!</p>
        <br />
        <p>Firstly, let's create a header file called <code>client.h</code> and a source called <code>client.c</code>.
        </p>
        <pre class="line-numbers">
          <code class="language-clike">
            #ifndef CLIENT_H
            #define CLIENT_H
            
            #include &lt;stdio.h&gt;

            // TODO client.h

            #endif // CLIENT_H
          </code>
        </pre>
        <pre class="line-numbers">
          <code class="language-clike">
            #include "client.h"

            // TODO client.c
          </code>
        </pre>
        <p>Neat. Now, let's talk about what the header file needs. We need three things: a linked list, a type for the
          linked list nodes, and a type for the client itself.</p>
        <p>The linked list structure will have:
        <ul>
          <li>A pointer to the head node of the list, NULL if list is empty</li>
          <li>A pointer to the tail node of the list, NULL if list is empty</li>
          <li>A size variable denoting how many clients are in the list</li>
        </ul>
        </p>
        <p>The linked list <i>node</i> structure will have:
        <ul>
          <li>A pointer to the node immediately after this node, NULL if none.</li>
          <li>A pointer to the tail immediately before this node, NULL if none.</li>
          <li>A pointer to the client struct that this node represents (the data itself!)</li>
        </ul>
        </p>
        <p>And finally, the client itself will have multiple things, and we may need to extend this definition later.
          For now, though:
        <ul>
          <li>A communication file descriptor</li>
          <li>A name</li>
          <li>A pointer to the write FILE.</li>
          <li>A pointer to the read FILE.</li>
        </ul>
        </p>
        <p>We'll expand on those last two in the client struct in a bit, but the first two should be trivial if you
          understand linked lists (if not, please read about them before proceeding - they are super important!). So,
          let's code them up!</p>
        <pre class="line-numbers">
          <code class="language-clike">
            /**
             * Typedef for the list itself. Keeps track of two pointers:
             * the head and the rear of the list. 
             */
            typedef struct client_list_s {
              struct client_node_s *head;   /* Head (first element) of the list. */
              struct client_node_s *tail;   /* Tail (last element) of the list. */
              size_t size;                  /* Number of currently-connected clients. */
            } client_list_t;

            /**
             * Node in the linked list. Abstracts the client_s struct and keeps 
             * two pointers: the previous node and the next node.
             */
            struct client_node_s {
              struct client_s *client;
              struct client_node_s *next;
              struct client_node_s *prev;
            };
          </code>
        </pre>
        <p>Let's discuss the client type for a minute (haven't coded it yet). Recall that when a client connects to the
          server in the connection while loop, we get two things: the name, and the communication file descriptor. These
          are the two (obvious) fields that we named earlier, but we also named two others: the read and write
          <code>FILE</code> pointers. If you've ever messed with file IO in C, <code>FILE *</code> should make sense to
          you. If not, however, it's still relatively simple.</p>
        <p>There are three "primary" types of file streams: standard input, standard output, and standard error. These,
          in C, are listed as <code>stdin, stdout, stderr</code> respectively. We can mimic the behavior of these file
          streams using <code>FILE</code> pointers with that communication file descriptor. We need to be able to read
          and write to the socket, right? So, how can we do that? It's simple, really (I know I keep saying that, but
          the concept itself is - the underlying code may be a bit more confusing to some)! We can use that unique
          communication file descriptor that we get from accept, and create <code>FILE</code> pointer objects from them,
          and dedicate one to reading, and one to writing!</p>
        <p>I hear some of you asking: "Why not just create <i>one</i> <code>FILE</code> pointer and use that instead?"
          Great question! The issue with this is that, when attempting to read from the client using only one file
          descriptor (or <code>FILE *</code> in this context), for instance, there can be no other activity on that file
          descriptor, meaning we can't write to the client at all until the read is complete. That's why we dedicate two
          <i>duplicate</i> file descriptors for this. Effectively, we create two pipes: one solely for reading, and one
          solely for writing for <i>that specific client and only that specific client.</i> Sounds confusing at first, I
          know! Let's start off by writing the client struct.</p>
        <pre class="line-numbers">
            <code class="language-clike">
              struct client_s {
                char *username;
                int comm_fd;
                
                FILE *read_fp;
                FILE *write_fp;
            };
            </code>
          </pre>
        <p>So far so good, eh? Again, the first two fields should be clear - they're retrieved from the
          <code>accept</code> call. The two bottom ones may be a bit fuzzy, but you can think of them as "links". You
          can use <code> FILE *</code> for reading any type of connection (for the most part - this may need
          fact-checking...)! You can read not only from sockets like we're doing, but also from files directly (which is
          generally what it's used for). Of course, we <i>could</i> just use the <code>read</code> and
          <code>write</code> or <code>send</code> and <code>recv</code> functions, but those are lower level, and using
          <code>FILE *</code> allows us to use high-level and string-friendly functions such as <code>fgets</code> and
          <code>getline</code>. More to come...</p>
        <p><a href="https://github.com/JoshuaCrotts/Multithreaded-Chat-Server-Tutorial/releases/tag/part2">GitHub Code
            for Part 2.</a></p>
      </div>
    </div>
  </section>
</body>

</html>